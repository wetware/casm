# Gradual Survey

Survey is a service for discovering peers from a namespace by surveying incrementally longer distance nodes

| Lifecycle Stage | Maturity       | Status | Latest Revision |
|-----------------|----------------|--------|-----------------|
| 1A              | Working Draft  | Active | r1, 2022-01-27  |

Authors: [@aratz-lasa], [@lthibault]

[@aratz-lasa]: https://github.com/aratz-lasa
[@lthibault]: https://github.com/lthibault

See libp2p's [lifecycle document][lifecycle-spec] for context about maturity level
and spec status.

[lifecycle-spec]: https://github.com/libp2p/specs/blob/master/00-framework-01-spec-lifecycle.md

## Table of Contents

- [Gradual Survey](#gradual-survey)
  - [Table of Contents](#table-of-contents)
  - [Motivation](#motivation)
  - [Protocol Specification](#protocol-specification)
    - [Conventions](#conventions)
    - [Definitions](#definitions)
    - [Protocol description](#protocol-description)
    - [Logical distance](#logical-distance)
    - [API](#api)
    - [Wire format](#wire-format)
  - [Known Issues](#known-issues)
  - [Alternate Designs](#alternate-designs)
  - [Core Team](#core-team)
  - [References](#references)

## Motivation
When a node wants to connect to a cluster, it needs to find peers that are already part of the namespace in a process called "bootstrap discovery".  Bootstrapping is usually performed either by a central service, or by a static list of long-lived bootstrap peers. For small networks or local development, this extra infrastructure imposes a significant burden. Moreover, these services represent concentrated points of failure, which adversely affect reliability. For these reasons, a decentralized bootstrap protocol is desired.

A common strategy is to attempt to connect to all addresses in a specific port range, for example 10.0.0.0/24.  This presents two problems:  one general, and one libp2p-specific. The general problem is twofold, firstly in that it scales poorly with the number of IPs that need to be scanned, and secondly in that the traffic generated by this "port-knocking" strategy is potentially very disruptive.  On large networks, it can easily overwhelm individual hosts.  And even on small networks, it is likely to be miscategorized as malicious traffic by network administrators and automated DoS countermeasures.  The libp2p-specific problem is more straightforward:  peers need some way of communicating their IDs in order to negotiate connections.

Currently, Libp2p offers a bootstrap protocol that solves both problems: multicast DNS (mDNS). However, this protocol may lead to scalability issues as indicated in [RFC 7558](https://datatracker.ietf.org/doc/html/rfc7558). The main such issue arises when there are many peers in the local network that receive the multicast request. Each of the receiver nodes respond to the multicast, overloading the request initiator (and potentially others). Therefore, we present a bootstrap protocol similar to mDNS that succeeds in alleviating network pressure via a double-pronged strategy:  (1) decreasing bandwidth consumption by means of a compact binary encoding, and (2) decreasing "burstiness" by means of a gradual-sampling approach.

The key insight of this second strategy is that peers respond at once to every request. Instead, peers should respond to a request only if they are within some logical distance of the requester.  Each request specifies both the originator's ID and a maximum distance, and each peer receiving the request should respond only if `distance(requester.id, recipient.id) < threshold`.  The requester should issue an initial request with a small distance, and increment it over subsequent requests until it finds a peer.  The obvious benefit of this approach is that it reduces the number of responses generated by each request, but note also that it limits the number of requests as well.  As with mDNS, _Gradual Survey_ is a multicast protocol, and peers may consume responses generated by requests from other peers.

## Protocol Specification
Gradual Survey is a protocol for bootstrapping cluster connectivity. It makes use of multicasting for sending discovery surveys to other peers.

### Conventions

>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://datatracker.ietf.org/doc/html/rfc2119) and [RFC 2119](https://datatracker.ietf.org/doc/html/rfc8174).

### Definitions
- **Requester**: the node that wants to discover peers from a namespace. That is to say, the node that sends a multicast message as a request for disovering peers.
- **Responder**: the node that receives a discovery request and is able to respond with known peers in the specified namespace.
- **Survey**: a communication pattern where a node A sends a multicast message, and it receives multiple responses. So, instead of request-response, it is request-multiresponse.
- **Namespace**: a logical grouping of nodes based on a string identifier called *namespace*.

### Protocol description
Gradual Survey is a simple request-multiresponse protocol (also called _surveyor-respondent_), that samples a progressively larger subset of the cluster. 

We begin by describing a simplified version of the protocol that generates a response from _all_ peers in a given namespace. 

1. Node A wants to find peers in namespace N. It multicasts a message as a request for information to nodes in the local network. The expected information is simply a set of peers known to be in N.
2. Node B receives A's request, and checks whether it is within the namespace N. If it is, it multicasts a message containing its signed peer record. If it is not in N, it simply ignores the message.
3. Node A receives B's response and joins the namespace N through B.

These steps are a high-level representation of the protocol and they ignore the _logical distance_, which is the key concept for making Survey scalable.  We now describe an extention to this simple survey protocol that makes it _gradual_.

In steps 1 and 2, the concept of _distance_ is used for incrementally discovering peers in namesapce N. In step 1, Node A includes a field that represents a logical distance threshold, D.  The expectation is that peers will respond only if their logical distance with A is less than D. Meanwhile, Node A waits for a configurable amount of time before incrementing D and re-issuing a request.  It repeats this process until a suitable bootstrap node is discovered.  In order to avoid bursts of multicast traffic, requesters MUST NOT issue additional requests after discovering at least one suitable peer.  They should instead employ alternative sampling methods (e.g. [PeX](./pex.md)) to discover subsequent peers. Requesters MAY consume multiple responses, however.  Likewise, implementations MAY choose to breifly listen for ambient responses before issuing requests of their own.

### Logical distance
As explained in [Protocol Description](#protocol-description), the logical distance is used for incrementally surveying more nodes. But how is the logical distance calculated?

The logical distance is between node A and B is calculated by XORing the last 4 bytes of their `peer.ID`s. The maximum logical distance is specified as a `uint8`. After XORing `peer.ID`s, the result is logically right-shiftted by the maximum logical distance. If the final result is 0, node B is within the maximum logical distance of A, otherwise it is outside.

**Example - within maximum distance:**
```
Node A ID (last 4 bytes) = 1110000110100000
Node B ID (last 4 bytes) = 1110000111100000
Maximum distance = 8

1110 0001 1010 0000 XOR 1110 0001 1110 0000 = 0000 0000 0100 0000
0000 0000 0100 0000 >> 8 = 0000 0000 0000 0000 =base10= 0
```

**Example - outside maximum distance:**
```
Node A ID (last 4 bytes) = 1110000110100000
Node B ID (last 4 bytes) = 1110000111100000
Maximum distance = 5

1110 0001 1010 0000 XOR 1110 0001 1110 0000 = 0000 0000 0100 0000
0000 0000 0100 0000 >> 5 = 0000 0000 0000 0010 =base10= 2 
```

### API
Survey provides a `discovery.Discovery` Libp2p interface.

```go
type Discovery interface {
    FindPeers(ctx context.Context, ns string, opts ...Option) (<-chan peer.AddrInfo, error)
    Advertise(ctx context.Context, ns string, opts ...Option) (time.Duration, error)
}
```

### Wire format
Survey encodes request and response messages using Capnproto. Capnproto si similar to Protocol Buffers but faster. Check [https://capnproto.org/](https://capnproto.org/) for understanding Capnproto encoding.

The Capnproto format for survey messages is the following:

```capnproto
struct Packet {
    namespace @0 :Text;

    union {
        request @1  :Request;
        response @2 :Envelope;
    }  

    struct Request {
        src      @0 :Envelope;
        distance @1 :UInt8;
    }
}
```

The _src_ field contains a signed `record.Envelope` containing the requester's `peer.PeerRecord`. The PeerRecord MUST be signed, so that receiver can validate the identity of the requester.  Additionally, implementations MAY define additional validation steps, for example checking that the record was signed by a known key.

The _distance_ field specifies the maximum logical distance for which the responder MUST reply.

Lastly, the _namespace_ is the namespace from which peers wants to be found.

## Known Issues

None (...so far!)

## Alternate Designs

- Consider `boot.Record` type to separate the bootstraping domain from ordinary peer-discovery.  See [#25](https://github.com/wetware/casm/issues/25)

## Core Team

- [@lthibault](https://github.com/lthibault)
- [@aratz-lasa](https://github.com/aratz-lasa) ★

★ Project Lead

## References
1. S. Cheshire and M. Krochmal. Multicast DNS. RFC 6762, Feb. 2013.
